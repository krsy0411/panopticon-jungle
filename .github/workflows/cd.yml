name: CD - Build & Deploy

on:
  push:
    branches:
      - feature/add-p50-90
      # - main
  workflow_dispatch:

env:
  AWS_REGION: ${{ secrets.AWS_REGION }}
  ECR_ACCOUNT_ID: ${{ secrets.ECR_ACCOUNT_ID }}
  QUERY_ECR_REPOSITORY: ${{ secrets.QUERY_ECR_REPOSITORY }}
  QUERY_ECS_CLUSTER: ${{ secrets.QUERY_ECS_CLUSTER }}
  QUERY_ECS_SERVICE: ${{ secrets.QUERY_ECS_SERVICE }}
  STREAM_ECR_REPOSITORY: ${{ secrets.STREAM_ECR_REPOSITORY }}
  STREAM_ECS_CLUSTER: ${{ secrets.STREAM_ECS_CLUSTER }}
  STREAM_ECS_SERVICE: ${{ secrets.STREAM_ECS_SERVICE }}
  STREAM_TASK_DEFINITION: ${{ secrets.STREAM_TASK_DEFINITION }}
  STREAM_CONTAINER_NAME: ${{ secrets.STREAM_CONTAINER_NAME }}
  QUERY_TASK_DEFINITION: ${{ secrets.QUERY_TASK_DEFINITION }}
  QUERY_CONTAINER_NAME: ${{ secrets.QUERY_CONTAINER_NAME }}

jobs:
  detect:
    name: Detect changed components
    runs-on: ubuntu-latest
    outputs:
      query_api: ${{ steps.filter.outputs.query_api }}
      stream_processor: ${{ steps.filter.outputs.stream_processor }}
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Detect paths
        id: filter
        uses: dorny/paths-filter@v3
        with:
          filters: |
            query_api:
              - 'backend/src/query-api/**'
              - 'backend/src/shared/**'
              - 'backend/package.json'
              - 'backend/package-lock.json'
              - 'backend/Dockerfile'
            stream_processor:
              - 'backend/src/stream-processor/**'
              - 'backend/src/shared/**'
              - 'backend/package.json'
              - 'backend/package-lock.json'
              - 'backend/Dockerfile'

  deploy-query:
    name: Build & deploy query API
    needs: detect
    if: needs.detect.outputs.query_api == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        working-directory: backend
        env:
          IMAGE_NAME: panopticon-query-api
        run: |
          docker build -f Dockerfile --target query-api -t "$IMAGE_NAME:${GITHUB_SHA}" .

      - name: Push image to ECR
        env:
          IMAGE_NAME: panopticon-query-api
        run: |
          ECR_URI="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${QUERY_ECR_REPOSITORY}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:${GITHUB_SHA}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${GITHUB_SHA}"
          docker push "${ECR_URI}:latest"
          echo "QUERY_ECR_URI=${ECR_URI}" >> $GITHUB_ENV

      - name: Register new task definition revision
        run: |
          aws ecs describe-task-definition --task-definition "$QUERY_TASK_DEFINITION" --query 'taskDefinition' --output json > task-def.json
          IMAGE="${{ env.QUERY_ECR_URI }}:${GITHUB_SHA}"
          cat task-def.json | jq --arg IMAGE "$IMAGE" --arg NAME "$QUERY_CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .registeredAt, .registeredBy, .compatibilities)
          ' > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "QUERY_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Trigger ECS deployment
        run: |
          aws ecs update-service \
            --cluster "$QUERY_ECS_CLUSTER" \
            --service "$QUERY_ECS_SERVICE" \
            --task-definition "$QUERY_TASK_DEF_ARN" \
            --force-new-deployment

  deploy-stream:
    name: Build & deploy stream processor
    needs: detect
    if: needs.detect.outputs.stream_processor == 'true'
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repo
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        run: |
          aws ecr get-login-password --region "$AWS_REGION" | docker login --username AWS --password-stdin "${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com"

      - name: Build Docker image
        working-directory: backend
        env:
          IMAGE_NAME: panopticon-stream-processor
        run: |
          docker build -f Dockerfile --target stream-processor -t "$IMAGE_NAME:${GITHUB_SHA}" .

      - name: Push image to ECR
        env:
          IMAGE_NAME: panopticon-stream-processor
        run: |
          ECR_URI="${ECR_ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${STREAM_ECR_REPOSITORY}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:${GITHUB_SHA}"
          docker tag "$IMAGE_NAME:${GITHUB_SHA}" "${ECR_URI}:latest"
          docker push "${ECR_URI}:${GITHUB_SHA}"
          docker push "${ECR_URI}:latest"
          echo "STREAM_ECR_URI=${ECR_URI}" >> $GITHUB_ENV

      - name: Register new task definition revision
        run: |
          aws ecs describe-task-definition --task-definition "$STREAM_TASK_DEFINITION" --query 'taskDefinition' --output json > task-def.json
          IMAGE="${{ env.STREAM_ECR_URI }}:${GITHUB_SHA}"
          cat task-def.json | jq --arg IMAGE "$IMAGE" --arg NAME "$STREAM_CONTAINER_NAME" '
            .containerDefinitions |= map(if .name == $NAME then .image = $IMAGE else . end)
            | del(.taskDefinitionArn, .revision, .status, .requiresAttributes, .registeredAt, .registeredBy, .compatibilities)
          ' > new-task-def.json
          NEW_TASK_DEF_ARN=$(aws ecs register-task-definition --cli-input-json file://new-task-def.json --query 'taskDefinition.taskDefinitionArn' --output text)
          echo "STREAM_TASK_DEF_ARN=$NEW_TASK_DEF_ARN" >> $GITHUB_ENV

      - name: Trigger ECS deployment
        run: |
          aws ecs update-service \
            --cluster "$STREAM_ECS_CLUSTER" \
            --service "$STREAM_ECS_SERVICE" \
            --task-definition "$STREAM_TASK_DEF_ARN" \
            --force-new-deployment
